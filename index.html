<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- BootStrap css -->
    <!-- <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">-->
</head>
<body>
    <!-- 개발자의 품격 유튜브 -->
    <!-- <div class="container">
        <div>이름 : <input type="text" id="name" />
        </div> -->
        <!-- select - click X , onchange O -->
        <!-- <div>지역 : <select id="city" onchange="changeCity();"> -->
            <!-- <option value="02" selected>서울</option>
            <option value="064">제주</option> -->
        <!-- </select>
        </div>
        <div>동네 :
            <select id="region_02">
                <option value="">강남</option>
                <option value="">서초</option>
            </select>
            <select id="region_064" style="display: none;">
                <option value="">제주시</option>
                <option value="">서귀포시</option> 
            </select>
            <select id="region_04" style="display: none;">
                <option value="">해운대</option>
                <option value="">광안리</option>
            </select>
        </div> -->
        <!-- <div>테스트 : <input type="text" id ="test" value="" /></div> -->
        <!-- <button type="button" onclick="regist();">등록</button>
    </div> -->

    <!-- BootStrap js -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous">
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous">
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous">
    </script> -->
    <!-- jQuery -->
    <!-- <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous">
    </script> -->

    <!-- js -->
    <!-- <script>
        // function regist(){
        //     // js
        //     //alert(document.getElementById("name").value);
        //     //alert(document.getElementById("city").value);
        //     // document.getElementById("name").value;

        //     // jQuery
        //     alert($("#name").val());
        //     alert($("#city").val());

        //     let obj = {
        //         name : "",
        //         city : ""
        //     };

        //     obj.name = $("#name").val();
        //     obj.city = $("#city").val();

        //     printConsole(obj);
        // }


        // 오브젝트 값 출력
        // function printConsole(data){
        //     console.log(data);
        // }

        // // 배열 값 출력
        // function loadCity(){
        //     let city = [{
        //         code: "02",
        //         name: "서울"
        //     },
        //     {
        //         code: "064",
        //         name: "제주"
        //     },
        //     {
        //         code: "04",
        //         name: "부산"
        //     }
        // ];  
        
        // 반복문 - for 통해서 코드내용 조건에 맞게 반복 (시작조건, 종료조건, 종료시키기 위해서 만드는 조건)
        // for(let i = 0; i < city.length ; i++){
        //     // 조건문
        //     if(i == 0){
        //         $('#city').append('<option value="'+ city[i].code + '"selected">' 
        //             + city[i].name + '</option>');
        //         }  
        //         else if(i == 1){
        //             $('#city').append('<option value="'+ city[i].code + '"selected">' 
        //             + city[i].name + '</option>');
        //                 }
        //             else {
        //                 $('#city').append('<option value="'+ city[i].code + '">' 
        //                     + city[i].name + '</option>');
        //             }
        // }

        //append 메서드 (HTML에 태그 추가등등 이용)
        // $('#city').append('<option value="02" selected>서울</option>');
        // $('#city').append('<option value="064" >제주</option>');
        // $('#city').append('<option value="04" >부산</option>');
        }
        // loadCity();

        // id값 city 부분의 value를 가져와서 숨기고 조건에 맞춰 보여줌
        // function changeCity(){
            // let city = document.getElementById("city").value;
            // document.getElementById("region_02").style.display = "none";
            // document.getElementById("region_064").style.display = "none";
            // // id의 값이 region_02,064 부분을 none 해주고 아래 코드를 이용해서
            // // id의 값이 02나 064가 나오면 그에 해당하는 display를 blank 해줘서 보임
            // document.getElementById("region_"+city).style.display = "";

            //jQuery 방식 (위 코드와 동일한 결과 보여줌)
        //     let city = $('#city').val();
        //     $('#region_02').hide();
        //     $('#region_064').hide();
        //     $('#region_04').hide();
        //     $('#region_'+city).show();
        // }

        //var , let , const
        //var x = 1;
        //x = x + 2;
        // var은 같은 변수명으로 한번 더 선언해도 작동 됨
        //var x = 4;

        //let y = 1;
        //y = y + 2;
        // let은 같은 변수명으로 한번 더 선언하면 작동 안되고 오류 뜸
        //let y = 4;

        //const z = 1;
        // const는 값을 재할당 하는것도 오류가 뜸 (절대 바뀌지 않음)
        //z = z + 2;

        //document.getElementById("test").value = z;

        //DataType
        //숫자, 소수점 숫자, 문자, 참/거짓(boolean), 오브젝트, 배열 등등
        // let a = 1;
        // a = 1.231;
        // a = "gyuseong";
        // a = true; // false

        // let obj = {
        //     name :"",
        //     city :""
        // };

        // let arr = [];
        //위부터 숫자 ~ 배열 순서

    </script> -->

    <script>
        //js 중급 (코딩앙마)
        //var는 선언하기 전에 사용할 수 있다 (호이스팅), 선언만 호이스팅 되고 값은 X
        //호이스팅 : 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것 처럼 행동
        //var와 다르게 에러가 생기는 이유, TDZ(Temporal Dead Zone) 때문
        //let 과 const는 할당을 하기 전 사용이 불가능 (잠재적 버그를 줄여줌)

        // 변수의 생성과점
        // var -   1.선언 및 초기화 단계
        //         2.할당 단계
        // let -   1.선언 단계
        //         2.초기화 단계
        //         3.할당 단계
        // const - 1.선언 + 초기화 + 할당 
        
        // var는 함수 스코프, let,const는 블록 스코프이다
        // 블록 스코프는 함수 if문 for문 while문 try/catch문 등
        // 블록 내부에서만 접근(지역변수) 외부에서 접근이 불가능
        // (if문 내부 var로 선언된 것 외부에서 사용 가능
        // let는 불가능, 중괄호 내부에서만 사용 가능)
        // var는 유일하게 함수 내부에서 선언되면 외부에서 사용이 불가능하다

        // 생성자 함수 (첫 글자는 대문자로)
        // this는 선언이 아닌 호출에 따라 달라짐 (호출자가 누구인가? 가르킴)
        // 함수에서 사용시 전역범위, 메소드는 객체
        // 아래 코드를 예시로 들면 this.title은 전역변수를 의미
        // function Item(title,price){
        //     this.title = title;
        //     this.price = price;
        //     this.showPrice = function(){
        //         console.log(`${title}가격은 ${price}원 입니다.`);
        //     }
        // }
        // // new 연산자를 사용해서 호출
        // // new로 실행해주면 this = {};와 return this; 를 알고리즘이 알아서 해준다
        // const item1 = new Item('인형', 3000);
        // const item2 = new Item('가방', 4000);
        // const item3 = new Item('지갑', 5000);
        // // new 없이 실행시 undefined가 출력된다 (return된 값이 없으므로)

        // console.log(item1,item2,item3);

        // item3.showPrice();

        // Computed property
        // let a = 'age';
        // const user = {
        //     name : 'Mike',
        //     [a] : 30 // age:30
        //     //대괄호로 묶어주면 문자열 a가 아닌 a라는 변수에 할당된 값이 들어감 (age : 30 이런식)
        //     //이를 계산된 프로퍼티 computed property라고 부름
        // }
        // console.log(a) //age (key 값이 age가 되는 것)
        // console.log(user[a]) // 30 
        // console.log(user) //name : 'Mike' , age : 30

        // //객체에서 사용 메서드들
        // object.assign()
        // //객체 복제,cloneUser를 하면 위와같은 코드에서는 객체 내부의 내용이 바뀜(한 객체에 두 변수접근)
        // //const newUser = Object.assign({}, user);
        // //중괄호는 초기 값, 두번째값(user)이 초기 값에 병합됨
        // //위 코드처럼 빈 객체에 user값이 병합되므로 복제되는 것 (이름 바꿔도 다른 객체이므로 문제X)
        // //하지만 중괄호 부분의 값이 이미 user안에 내용과 동일하다면 덮어쓰고 아니면 추가해줌
        // //세가지의 값도 하나로 합칠 수 있음 Object.assign(user, info1, info2) - user에 info1,2 넣음
            //예시 코드
            // const user = {
            //     name : "Mike",
            //     age : 30,
            // }
            // const user2 = Object.assign({},user);
            // user2.name = "Tom";
            
            // console.log(user); //name: 'Mike', age: 30
            // console.log(user2);//name: 'Tom', age: 30
            // 위 코드에서 Object.assign을 사용하지 않고 그대로 user2.name = "Tom"; 하면
            // user객체의 값도 모두 변경되어 아래의 출력에 Mike인 기존값이 아닌 둘다 Tom으로 출력된다.

        // object.keys()
        // //키, 배열 반환, user의 객체안에 name과 age와 gender등의 값이 있다면 이걸 배열로 반환시켜줌
        
        // object.values()
        // //값, 배열 반환, keys와 다르게 값만 가져오고 싶으면 values 쓰면 됨 (name의 값, age의 값 등등)

        // object.entries()
        // //키/값, 배열 반환, key와 배열의 값 모두 묶어 줌 ["name","Mike"],["age", 30] 이런식으로
        
        // object.fromEntries()
        // //키/값 배열을 객체로 바꿔줌, 아래코드 실행시 {name : 'Mike', age : 30, gender : 'male',}
        // //위 실행시 부분처럼 결과가 나온다
        // const arr = [
        //     ["name","Mike"],
        //     ["age",30],
        //     ["gender","male"]
        // ]; //앞이 key값 , 뒤에가 value값 (이 코드에서 name는 key값, Mike는 value값)
        // Object.fromEntries(arr); 

        //심볼 (Symbol)
        //property key : 문자형 , 객체 property key 문자형 가능하고, 하나 더 가능 그것이 심볼형
        //심볼은 new를 붙이지 않음 (유일한 식별자를 만들 때 사용, 유일성 보장 모든 코드중 하나)
        // 심볼을 만들 때 설명을 해줄 수 있음 (const id = Symbol('id'); 이런식으로)
        // 문자열을 전달해주면 되는데 심볼 생성에 영향을 주지는 않음
        // const id = Symbol('id');
        // const id2 = Symbol('id');
        // 위 코드를 찍어보면 Symbol(id) 라고 동일하게 나오지만 id === id2 / id == id2 모두 false가 나옴

        //객체의 키에 사용
        // const id = Symbol('id');
        // const user = {
        //     name : 'Mike',
        //     age : 30,
        //     [id] : 'myid' //property key를 심볼형으로 넣음
        // } //user로 찍으면 name: "Mike", age: 30, Symbol(id): "myid" 라고 나옴
        // Object.keys(user); //["name", "age"]
        // Object.values(user); //["Mike", 30]
        // Object.entries(user); //[Array(2), Array(2)]
        //이런 메서드들은 key가 심볼형인 property는 건너 뜀(for in을 사용해도 건너 뜀)
        //심볼은 특정위치의 원본 데이터 건드리지 않고 속성추가가 가능하다

        //Symbol.for() : 전역 심볼
        // 하나의 심볼만 보장받을 수 있음
        // 없으면 만들고, 있으면 가져오기 때문
        // Symbol 함수는 매번 다른 Symbol 값을 생성하지만,
        // Symbol.for 메서드는 하나를 생성한 뒤 키를 통해 같은 Symbol을 공유
        // // 예시코드
        // const id1 = Symbol.for('id');
        // const id2 = Symbol.for('id');
        // id1 === id2; //true (for이 심볼에 없다면 false가 나올 것)
        
        // Symbol.keyFor(id1) //이 코드 이용시 이름을 얻을 수 있음 결과값은 'id' 라고 나옴
        
        // 전역 심볼이 아닌경우
        // const id = Symbol('id 입니다.');
        // id.description; //'id 입니다,' 라고 출력됨 (전역심볼이 아닌 심볼의 이름 알아내는 방법)

        //숨겨진 심볼 키 보는 방법
        // Object.getOwnPropertySymbols(user); // [Symbol(id)] 심볼들만 볼 수 있음
        // Reflect.ownKeys(user); // ["name", "age", Symbol(id)] 객체의 모든 키 값을 볼 수 있음
        // 대부분의 라이브러리, 내장 함수등은 이런 메서드 사용안함 (걱정말고 사용해도 됨)
        
        //심볼의 장점이 보이는 예시 코드
            // 다른 개발자가 만든 객체
        // const user = {
        //     name: "Mike",
        //     age: 30,
        // };

        // const user2 = {
        //     name: "Tom",
        //     age: 29,
        // }

        //     //내 작업
        // //user.showName = function(){} // user.showName = function(){} 이라고 그대로 출력된다
        
        // //위 코드가 아닌 아래 코드로 실행시 Mike / His name is Mike / His age is 30 이라고 출력된다
        // const showName = Symbol("show name"); //선언 (show name은 설명)
        // //const showName2 = Symbol("show name2");
        // //심볼이 선언되는 변수명은 상관없고 심볼을 통해서 고유값이 됨

        // user[showName] = function() {
        //     //user는 객체명 , showName은 Symbol을 이용해 고유값으로 되는 user의 값들
        //     //user의 값들을 showName을 통해서 가져온다고 이해 (이걸 Symbol로 선언했으니 고유값)

        //     //console.log(showName === showName); //true
        //     //console.log(showName === Symbol("show name")); //false
        //     console.log(this.name,this.age);
        // }

        // user[showName](); //위 생성된 함수 실행

        //     //사용자에게 보이는 메시지
        // for (let key in user){
        //     console.log(`His ${key} is ${user[key]}.`);
        // }
        //for in은 for (const 변수 in 객체){} 와 같은 방법으로 사용
        //여기서 key는 객체안의 key값이고 user은 객체명이므로 
        //user[key]를 통해서 user에 key값이 동일한거의 value를 가져옴
        //for in문은 루프다.

        //Number , Math
        //.toString(10진수) -> 2진수/16진수
        //let num = 10; (2진수)
        //num.toString(); 결과값 "10" / num.toString(2); 결과값 "1010"
        //let num2 = 255; (16진수)
        //num2.toString(16); 결과값 "ff" / num2.toString(10); 결과값 "255"

        //Math
        // Math.PI; // 파이값이 나옴
        // Math.ceil() //올림 (괄호안의 내용 소수점 상관없이 올림)
        // Math.floor() //내림 (괄호안의 내용 소수점 상관없이 내림)
        // Math.round() //반올림 (괄호안의 내용 소수점이 5보다 높으면 올리고 아니면 내림)

        // 소수점 둘째자리 까지 표현되게 해달라고 하면 셋째 자리에서 반올림 하면 됨
        // 요구하는 숫자의 값이 30.1234의 경우로 해보자

        // 방법 1 (round)
        // let userRate = 30.1234;
        // Math.round(userRate * 100)/100 //30.12가 출력된다

        // 방법 2 (toFixed)
        // userRate.toFixed(2); 해주면 30.12로 나오고
        // 괄호부분을 0으로 하면 정수로 30이 나오고
        // 괄호부분을 6으로 하면 나머지 부분을 0으로 채워줘서 30.123400 이 됨
        // 주의할것은 문자열로 반환함, 그래서 Number(userRate.toFixed(2)); 를 해주는것이 좋다

        //isNaN() (숫자가 아닌지 판단해줌)
        //let x = Number('X'); 출력값은 NaN
        //isNaN(x) 출력 true , isNaN(3) 출력 false

        //parseInt() 문자열을 숫자로 바꿔줌(Number과 다르게 문자가 혼용되도 동작함)
        // let margin = '10px';
        // parseInt(margin); // 10 출력 (읽을 수 있는 부분까지만 읽음 숫자가 앞에 들어가서 된 것)
        // //숫자로 시작하지 않으면 NaN 반환함
        // Number(margin); // NaN 출력
        // //ㅋparseInt는 두번째 인수를 받아 진수를 지정 가능(2진수 10진수 16진수 등등)
        // let redColor = 'f3'
        // parseInt(redcolor, 16); //243 (16진수로 출력)
        // parseInt('11',2) // 3 (2진수로 출력)
        
        //parseFloat() 부동 소수점을 반환함, Int는 소수점 무시하고 정수만 반환

        //몇가지 Math함수
        //Math.random() // 0~1까지 무작위 숫자 생성 (소수점 매우 많게)
        //1~100까지 임의의 숫자 뽑고싶으면
        //Math.floor(Math.random()*100)+1
        //설명 Math.random에서 0.6789가 만들어졌다고 가정하면
        //*100을 해줘서 67.89를 만들어주고
        //floor을 통해서 내림으로 67을 만들어주는데
        //여기서 +1을 해주는 이유는 0이 나올수도 있어서 최소값인 1이 나오게 하기위해 더해줌
        //결국 출력값은 68이 되는 것

        //Math.max() / Math.min()
        //Math.max(1,4,-1,5,10,9,5.54); //10 최대값
        //Math.min(1,4,-1,5,10,9,5.54); //-1 최소값

        //Math.abs() 절대값 구해줌 (absolute 약자임)
        //Math.abs(-1) // 출력값 1

        //Math.pow(n,m) 제곱 (power 약자임)
        //Math.pow(2,10) // 출력값 1024

        //Math.sqrt() 제곱근 (square root 약자임)
        //Math.sqrt(16) // 출력값 4

        //문자열 String
        //여러줄 사용시 벡틱을 이용하는것이 좋다 아니라면 \n을 해줘야하는 번거로움이 생김
        //length 배열,문자열 길이 , 대괄호 통해 특정문자로 접근도 가능 (한글자만 바꾸는것은 안됨)
        
        //toUpperCase() 대문자로 변환 / toLowerCase() 소문자로 변환

        //str.indexOf(text) 문자를 인수로 받아 몇번째에 위치하는지 알려줌
        //let desc = "Hi guys. Nice to meet you.";
        //desc.indexOf('to'); //출력값 14
        // 찾는문자 없으면 -1 반환 , 찾는문자 있어도 첫번째 위치만 반환해줌
        // if에서 사용시 첫 문자를 찾으면 값이 0이 나오므로 false가 되서 실행안됨
        // 그래서 if(desc.indexOf('Hi') > -1){} 이런식으로 조건 해주면 된다

        //str.slice(n,m) 특정범위 문자열만 뽑기
        // n은 시작점, m은 ~까지인데 , 없으면 문자열 끝까지, 양수면 그 숫자까지(포함하지 않음)
        // 음수면 끝에서부터 셈 (5 적으면 4까지 반환)
        // let desc = "abcdefg" 하고 desc.slice(2) 는 cdefg 반환
        // desc.slice(0,5) 하면 abcde 반환, slice(2,-2) 는 cde 반환

        //str.substring(n,m) n과 m 사이 문자열 반환 (서로 바꿔도 동작함) 음수는 0으로 인식

        //str.substr(n,m) n부터 시작, m개를 가져옴 
        //desc.substr(2,4) // "cdef" 출력

        //str.trim 앞, 뒤 공백제거
        
        //str.repeat(n) 문자열을 n번 반복함
        //let hello = "hello!";
        //hello.repeat(2); // "hello!hello!" 출력

        //문자열 비교
        //"a".codePointAt(0); //출력값 97 (십진법 소문자 a의 값)
        //String.fromCodePoint(97); //"a" (십진법 97응 문자로 바꿈)
        
        
        //예제 1. (제목만 보기)
        // let list = [
        //     "01. 들어가며",
        //     "02. JS의 역사",
        //     "03. 자료형",
        //     "04. 함수",
        //     "05. 배열",
        // ];

        // let newList = [];

        // for(let i = 0; i < list.length; i++){
        //     newList.push(list[i].slice(4));
        // }
        // console.log(newList);


        //예제 2. (금칙어 : 콜라)
        // function hasCola(str){
        //     if(str.indexOf('콜라') > -1 ){
        //         console.log("금칙어가 있습니다.");
        //     } else
        //         console.log("통과")
        // }

        // hasCola("와 사이다가 짱이야"); // -1 나옴 (-1은 true) 그래서 if 조건에 > -1 해주면 됨
        // hasCola("무슨소리, 콜라가 최고"); // 0은  false
        // hasCola("콜라"); // 0


        // 예제 3. (2와 동일한 것 includes 사용)
        // function hasCola(str){
        //     if(str.includes('콜라')){
        //         console.log("금칙어가 있습니다.");
        //     } else
        //         console.log("통과")
        // }

        // hasCola("와 사이다가 짱이야"); 
        // hasCola("무슨소리, 콜라가 최고"); 
        // hasCola("콜라"); 
        //includes는 문자가 있는지를 확인하기 때문에 > -1 안해줘도 됨

    </script>
</body>
</html>