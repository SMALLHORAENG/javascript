<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- BootStrap css -->
    <!-- <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">-->
</head>
<body>
    <!-- 개발자의 품격 유튜브 -->
    <!-- <div class="container">
        <div>이름 : <input type="text" id="name" />
        </div> -->
        <!-- select - click X , onchange O -->
        <!-- <div>지역 : <select id="city" onchange="changeCity();"> -->
            <!-- <option value="02" selected>서울</option>
            <option value="064">제주</option> -->
        <!-- </select>
        </div>
        <div>동네 :
            <select id="region_02">
                <option value="">강남</option>
                <option value="">서초</option>
            </select>
            <select id="region_064" style="display: none;">
                <option value="">제주시</option>
                <option value="">서귀포시</option> 
            </select>
            <select id="region_04" style="display: none;">
                <option value="">해운대</option>
                <option value="">광안리</option>
            </select>
        </div> -->
        <!-- <div>테스트 : <input type="text" id ="test" value="" /></div> -->
        <!-- <button type="button" onclick="regist();">등록</button>
    </div> -->

    <!-- BootStrap js -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous">
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous">
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous">
    </script> -->
    <!-- jQuery -->
    <!-- <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous">
    </script> -->

    <!-- js -->
    <!-- <script>
        // function regist(){
        //     // js
        //     //alert(document.getElementById("name").value);
        //     //alert(document.getElementById("city").value);
        //     // document.getElementById("name").value;

        //     // jQuery
        //     alert($("#name").val());
        //     alert($("#city").val());

        //     let obj = {
        //         name : "",
        //         city : ""
        //     };

        //     obj.name = $("#name").val();
        //     obj.city = $("#city").val();

        //     printConsole(obj);
        // }


        // 오브젝트 값 출력
        // function printConsole(data){
        //     console.log(data);
        // }

        // // 배열 값 출력
        // function loadCity(){
        //     let city = [{
        //         code: "02",
        //         name: "서울"
        //     },
        //     {
        //         code: "064",
        //         name: "제주"
        //     },
        //     {
        //         code: "04",
        //         name: "부산"
        //     }
        // ];  
        
        // 반복문 - for 통해서 코드내용 조건에 맞게 반복 (시작조건, 종료조건, 종료시키기 위해서 만드는 조건)
        // for(let i = 0; i < city.length ; i++){
        //     // 조건문
        //     if(i == 0){
        //         $('#city').append('<option value="'+ city[i].code + '"selected">' 
        //             + city[i].name + '</option>');
        //         }  
        //         else if(i == 1){
        //             $('#city').append('<option value="'+ city[i].code + '"selected">' 
        //             + city[i].name + '</option>');
        //                 }
        //             else {
        //                 $('#city').append('<option value="'+ city[i].code + '">' 
        //                     + city[i].name + '</option>');
        //             }
        // }

        //append 메서드 (HTML에 태그 추가등등 이용)
        // $('#city').append('<option value="02" selected>서울</option>');
        // $('#city').append('<option value="064" >제주</option>');
        // $('#city').append('<option value="04" >부산</option>');
        }
        // loadCity();

        // id값 city 부분의 value를 가져와서 숨기고 조건에 맞춰 보여줌
        // function changeCity(){
            // let city = document.getElementById("city").value;
            // document.getElementById("region_02").style.display = "none";
            // document.getElementById("region_064").style.display = "none";
            // // id의 값이 region_02,064 부분을 none 해주고 아래 코드를 이용해서
            // // id의 값이 02나 064가 나오면 그에 해당하는 display를 blank 해줘서 보임
            // document.getElementById("region_"+city).style.display = "";

            //jQuery 방식 (위 코드와 동일한 결과 보여줌)
        //     let city = $('#city').val();
        //     $('#region_02').hide();
        //     $('#region_064').hide();
        //     $('#region_04').hide();
        //     $('#region_'+city).show();
        // }

        //var , let , const
        //var x = 1;
        //x = x + 2;
        // var은 같은 변수명으로 한번 더 선언해도 작동 됨
        //var x = 4;

        //let y = 1;
        //y = y + 2;
        // let은 같은 변수명으로 한번 더 선언하면 작동 안되고 오류 뜸
        //let y = 4;

        //const z = 1;
        // const는 값을 재할당 하는것도 오류가 뜸 (절대 바뀌지 않음)
        //z = z + 2;

        //document.getElementById("test").value = z;

        //DataType
        //숫자, 소수점 숫자, 문자, 참/거짓(boolean), 오브젝트, 배열 등등
        // let a = 1;
        // a = 1.231;
        // a = "gyuseong";
        // a = true; // false

        // let obj = {
        //     name :"",
        //     city :""
        // };

        // let arr = [];
        //위부터 숫자 ~ 배열 순서

    </script> -->

    <script>
        //js 중급 (코딩앙마)
        //var는 선언하기 전에 사용할 수 있다 (호이스팅), 선언만 호이스팅 되고 값은 X
        //호이스팅 : 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것 처럼 행동
        //var와 다르게 에러가 생기는 이유, TDZ(Temporal Dead Zone) 때문
        //let 과 const는 할당을 하기 전 사용이 불가능 (잠재적 버그를 줄여줌)

        // 변수의 생성과점
        // var -   1.선언 및 초기화 단계
        //         2.할당 단계
        // let -   1.선언 단계
        //         2.초기화 단계
        //         3.할당 단계
        // const - 1.선언 + 초기화 + 할당 
        
        // var는 함수 스코프, let,const는 블록 스코프이다
        // 블록 스코프는 함수 if문 for문 while문 try/catch문 등
        // 블록 내부에서만 접근(지역변수) 외부에서 접근이 불가능
        // (if문 내부 var로 선언된 것 외부에서 사용 가능
        // let는 불가능, 중괄호 내부에서만 사용 가능)
        // var는 유일하게 함수 내부에서 선언되면 외부에서 사용이 불가능하다

        // 생성자 함수 (첫 글자는 대문자로)
        // this는 선언이 아닌 호출에 따라 달라짐 (호출자가 누구인가? 가르킴)
        // 함수에서 사용시 전역범위, 메소드는 객체
        // 아래 코드를 예시로 들면 this.title은 전역변수를 의미
        // function Item(title,price){
        //     this.title = title;
        //     this.price = price;
        //     this.showPrice = function(){
        //         console.log(`${title}가격은 ${price}원 입니다.`);
        //     }
        // }
        // // new 연산자를 사용해서 호출
        // // new로 실행해주면 this = {};와 return this; 를 알고리즘이 알아서 해준다
        // const item1 = new Item('인형', 3000);
        // const item2 = new Item('가방', 4000);
        // const item3 = new Item('지갑', 5000);
        // // new 없이 실행시 undefined가 출력된다 (return된 값이 없으므로)

        // console.log(item1,item2,item3);

        // item3.showPrice();

        // Computed property
        // let a = 'age';
        // const user = {
        //     name : 'Mike',
        //     [a] : 30 // age:30
        //     //대괄호로 묶어주면 문자열 a가 아닌 a라는 변수에 할당된 값이 들어감 (age : 30 이런식)
        //     //이를 계산된 프로퍼티 computed property라고 부름
        // }
        // console.log(a) //age (key 값이 age가 되는 것)
        // console.log(user[a]) // 30 
        // console.log(user) //name : 'Mike' , age : 30

        // //객체에서 사용 메서드들
        // object.assign()
        // //객체 복제,cloneUser를 하면 위와같은 코드에서는 객체 내부의 내용이 바뀜(한 객체에 두 변수접근)
        // //const newUser = Object.assign({}, user);
        // //중괄호는 초기 값, 두번째값(user)이 초기 값에 병합됨
        // //위 코드처럼 빈 객체에 user값이 병합되므로 복제되는 것 (이름 바꿔도 다른 객체이므로 문제X)
        // //하지만 중괄호 부분의 값이 이미 user안에 내용과 동일하다면 덮어쓰고 아니면 추가해줌
        // //세가지의 값도 하나로 합칠 수 있음 Object.assign(user, info1, info2) - user에 info1,2 넣음
            //예시 코드
            // const user = {
            //     name : "Mike",
            //     age : 30,
            // }
            // const user2 = Object.assign({},user);
            // user2.name = "Tom";
            
            // console.log(user); //name: 'Mike', age: 30
            // console.log(user2);//name: 'Tom', age: 30
            // 위 코드에서 Object.assign을 사용하지 않고 그대로 user2.name = "Tom"; 하면
            // user객체의 값도 모두 변경되어 아래의 출력에 Mike인 기존값이 아닌 둘다 Tom으로 출력된다.

        // object.keys()
        // //키, 배열 반환, user의 객체안에 name과 age와 gender등의 값이 있다면 이걸 배열로 반환시켜줌
        
        // object.values()
        // //값, 배열 반환, keys와 다르게 값만 가져오고 싶으면 values 쓰면 됨 (name의 값, age의 값 등등)

        // object.entries()
        // //키/값, 배열 반환, key와 배열의 값 모두 묶어 줌 ["name","Mike"],["age", 30] 이런식으로
        
        // object.fromEntries()
        // //키/값 배열을 객체로 바꿔줌, 아래코드 실행시 {name : 'Mike', age : 30, gender : 'male',}
        // //위 실행시 부분처럼 결과가 나온다
        // const arr = [
        //     ["name","Mike"],
        //     ["age",30],
        //     ["gender","male"]
        // ]; //앞이 key값 , 뒤에가 value값 (이 코드에서 name는 key값, Mike는 value값)
        // Object.fromEntries(arr); 

        //심볼 (Symbol)
        //property key : 문자형 , 객체 property key 문자형 가능하고, 하나 더 가능 그것이 심볼형
        //심볼은 new를 붙이지 않음 (유일한 식별자를 만들 때 사용, 유일성 보장 모든 코드중 하나)
        // 심볼을 만들 때 설명을 해줄 수 있음 (const id = Symbol('id'); 이런식으로)
        // 문자열을 전달해주면 되는데 심볼 생성에 영향을 주지는 않음
        // const id = Symbol('id');
        // const id2 = Symbol('id');
        // 위 코드를 찍어보면 Symbol(id) 라고 동일하게 나오지만 id === id2 / id == id2 모두 false가 나옴

        //객체의 키에 사용
        // const id = Symbol('id');
        // const user = {
        //     name : 'Mike',
        //     age : 30,
        //     [id] : 'myid' //property key를 심볼형으로 넣음
        // } //user로 찍으면 name: "Mike", age: 30, Symbol(id): "myid" 라고 나옴
        // Object.keys(user); //["name", "age"]
        // Object.values(user); //["Mike", 30]
        // Object.entries(user); //[Array(2), Array(2)]
        //이런 메서드들은 key가 심볼형인 property는 건너 뜀(for in을 사용해도 건너 뜀)
        //심볼은 특정위치의 원본 데이터 건드리지 않고 속성추가가 가능하다

        //Symbol.for() : 전역 심볼
        // 하나의 심볼만 보장받을 수 있음
        // 없으면 만들고, 있으면 가져오기 때문
        // Symbol 함수는 매번 다른 Symbol 값을 생성하지만,
        // Symbol.for 메서드는 하나를 생성한 뒤 키를 통해 같은 Symbol을 공유
        // // 예시코드
        // const id1 = Symbol.for('id');
        // const id2 = Symbol.for('id');
        // id1 === id2; //true (for이 심볼에 없다면 false가 나올 것)
        
        // Symbol.keyFor(id1) //이 코드 이용시 이름을 얻을 수 있음 결과값은 'id' 라고 나옴
        
        // 전역 심볼이 아닌경우
        // const id = Symbol('id 입니다.');
        // id.description; //'id 입니다,' 라고 출력됨 (전역심볼이 아닌 심볼의 이름 알아내는 방법)

        //숨겨진 심볼 키 보는 방법
        // Object.getOwnPropertySymbols(user); // [Symbol(id)] 심볼들만 볼 수 있음
        // Reflect.ownKeys(user); // ["name", "age", Symbol(id)] 객체의 모든 키 값을 볼 수 있음
        // 대부분의 라이브러리, 내장 함수등은 이런 메서드 사용안함 (걱정말고 사용해도 됨)
        
        //심볼의 장점이 보이는 예시 코드
            // 다른 개발자가 만든 객체
        const user = {
            name: "Mike",
            age: 30,
        };

        const user2 = {
            name: "Tom",
            age: 29,
        }

            //내 작업
        //user.showName = function(){} // user.showName = function(){} 이라고 그대로 출력된다
        
        //위 코드가 아닌 아래 코드로 실행시 Mike / His name is Mike / His age is 30 이라고 출력된다
        const showName = Symbol("show name"); //선언 (show name은 설명)
        //const showName2 = Symbol("show name2");
        //심볼이 선언되는 변수명은 상관없고 심볼을 통해서 고유값이 됨
        user[showName] = function() {
            //user는 객체명 , showName은 Symbol을 이용해 고유값으로 되는 user의 값들

            //console.log(showName === showName); //true
            //console.log(showName === Symbol("show name")); //false
            console.log(this.name,this.age);
        }

        user[showName](); //위 생성된 함수 실행

            //사용자에게 보이는 메시지
        for (let key in user){
            console.log(`His ${key} is ${user[key]}.`);
        }
        //for in은 for (const 변수 in 객체){} 와 같은 방법으로 사용
        //여기서 key는 객체안의 key값이고 user은 객체명이므로 
        //user[key]를 통해서 user에 key값이 동일한거의 value를 가져옴
        //for in문은 루프다.

    </script>
</body>
</html>